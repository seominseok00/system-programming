# 시그널의 개념

시그널(Signal)은 소프트웨어 인터럽트로 프로세스에서 뭔가 발생했음을 알리는 간단한 메시지를 비동기적으로 보내는 것이다.

<br>

### 시그널의 발생

시그널은 다음과 같은 3가지 경우에 발생한다.

- 0으로 나누기처럼 프로그램에서 예외적인 상황이 발생하는 경우
- kill 함수와 같이 시그널을 보내는 함수를 사용해 다른 프로세스에 시그널을 보내는 경우
- 사용자가 ctrl + c 같은 인터럽트 키를 입력한 경우

<br>

### 시그널 처리 방법

시그널을 받은 프로세스는 4가지 방법으로 시그널을 처리할 수 있다.

- 시그널에 따른 기본 동작을 수행한다. (대부분의 시그널의 기본 동작은 프로세스 종료이다)
- 시그널을 무시한다. (이 경우 운영체제에서 시그널을 전달하지 않음)
- 시그널 처리를 위한 함수(Signal Handler)를미리 지정해놓고 시그널을 받으면 해당 함수를 호출해 처리한다.
- 특정 부분이 실행되는 동안 시그널이 발생하지 않도록 블록한 다음, 시그널 블록이 해제되면 전달된다.

<br>

### 시그널의 종류

시그널은 signal.h 헤더파일에 정의돼 있다.

기본 처리에 있는 종료는 프로세스가 그냥 종료되는 것이고, 코어 덤프(core dump)는 비정상 종료로 프로세스 이미지를 덤프해서 문제가 어디서 발생했는지 디버깅 할 수 있도록 코어 파일을 만들고 종료하는 것이다.

| 시그널  | 번호 | 기본 처리 |                          발생 요건                           |
| :-----: | :--: | :-------: | :----------------------------------------------------------: |
| SIGHUP  |  1   |   종료    |          행업으로 터미널과 연결이 끊어졌을 때 발생           |
| SIGINT  |  2   |   종료    |       인터럽트로 사용자가 **Ctrl + C**‌를 입력하면 발생       |
| SIGQUIT |  3   | 코어 덤프 |      종료 신호로 사용자가 **Ctrl + \\**를 입력하면 발생      |
| SIGKILL |  9   |   종료    |                       강제 종료로 발생                       |
| SIGUSR1 |  16  |   종료    | 사용자 정의 시그널로 사용자가 자신만의 유의미한 시그널을 보내고 싶을 때 사용 |
| SIGCONT |  25  |   무시    |              종료된 프로세스를 재시작할 때 발생              |

<br>

# 시그널 보내기

시그널을 보내는 주체는 커널, 다른 프로세스, 사용자 세 가지로 프로그램에서 시그널을 보내려면 kill, raise, abort 함수를 사용하면 된다.

<br>

### 시그널 보내기 함수

##### 시그널 보내기: kill

```c++
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```

- pid: 시그널을 받을 프로세스의 ID
- sig: pid로 지정한 프로세스에 보내려는 시그널

kill 함수는 pid에 대응하는 프로세스에 sig로 지정한 시그널을 보낸다.

pid는 특정 프로세스 또는 프로세스 그룹을 의미하며, sig에 0(Null 시그널)을 지정하면 실제로 시그널을 보내지 않고, pid가 정상인지 검사한다.

pid에 지정한 값에 따라 시그널을 어떻게 보낼 것인지를 결정한다.

- pid > 0: pid로 지정한 프로세스에게 시그널을 보낸다.
- pid < -2: 프로세스 그룹 ID가 pid의 절대값인 프로세스 그룹에 속하고 시그널을 보낼 권한을 갖고 있는 모든 프로세스에게 시그널을 보낸다.
- pid = -1: 시그널을 보내는 프로세스의 유효 사용자 ID가 root가 아니면, 트별한 프로세스를 제외하고 프로세스의 실제 사용자 ID가 시그널을 보내는 프로세스의 유효 사용자 ID와 같은 모든 프로세스에게 시그널을 보낸다.
- pid = 0: 특별한 프로세스(스케줄러)를 제외하고, 시그널을 보내는 프로세스의 프로세스 그룹 ID와 같은 모든 프로세스에게 시그널을 보낸다.

<br>

##### 예제 7-1

```c++
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <stdio.h>

int main()
{
    printf("Before SIGCONT Signal to parent.\n");

    kill(getppid(), SIGCONT);  // 부모 프로세스에게 SIGCONT 시그널을 보냄

    printf("Before SIGQUIT Signal to me.\n");

    kill(getpid(), SIGQUIT);  // 자기 자신에게 SIGQUIT 시그널을 보냄

    printf("After SIGQUIT Signal.\n");  // 14 line에서 프로세스가 종료됐기 때문에 출력 X

    return 0;
}
```

<img width="682" alt="스크린샷 2022-11-14 오후 11 00 44" src="https://user-images.githubusercontent.com/110466566/201678999-5dd86ce8-fe7e-4bc7-b24c-95d561f3f768.png">

SIGCONT 시그널은 기본 처리가 무시이기 때문에 특별한 처리를 하지 않지만, SIGQUIT 시그널은 코어 덤프를 발생 시키며 프로세스를 종료하기 때문에 

After SIGQUIT Signal이 출력되지 않은 것을 확인할 수 있다.

<br>

이어서 볼 raise, abort 함수는 자기 자신에게만 signal을 보내는 함수이다.

##### 시그널 보내기: raise

```c++
#include <signal.h>

int raise(int sig);
```

- sig: 보내려는 시그널 번호

raise 함수는 자신을 호출한 프로세스에게 인자로 지정한 시그널을 보낸다. 만약 시그널 핸들러가 호출되면 시그널 핸들러의 수행이 끝날 때까지 raise 함수는 리턴하지 않는다.

수행에 성공하면 0, 실패하면 -1을 리턴한다.

<br>

##### 시그널 보내기: abort

```c++
#include <stdlib.h>

void abort(void);
```

abort 함수도 마찬가지로 호출한 프로세스에게 SIGABRT 시그널을 보낸다. SIGABRT 시그널은 프로세스를 비정상적으로 종료시키고(따라서 abort 함수의 리턴 값이 없다) 코어 덤프 파일을 생성한다.
